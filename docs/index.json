[{"categories":["操作系统"],"content":"想起前同事有一天问我的一个问题，blocking|unblocking I/O 跟 sync|async I/O 有什么不同？ 前几天带着这个问题，读了《Unix Network Programming - Volume 1》。本文准备学以致用，把 Unix 系统上 5 种可用的 I/O 模型用自己的话讲清楚，并把前面这个问题给解答了。 正常情况下，一次在 socket 上进行的输入操作包含两个清楚的阶段： 等待数据在内核中就绪 等待数据到达网卡，当数据包到达时，它们被拷贝到内核中的缓冲区。 将数据从内核的缓冲区拷贝至应用的缓冲区中 Unix 提供了 5 种可用的 I/O 模型，它们的差异主要在与这两个阶段中应用跟内核之间的交互方式： blocking I/O nonblocking I/O I/O multiplexing (select and poll) signal driven I/O (SIGIO) asynchronous I/O (the POSIX aio_functions) ","date":"2021-12-11","objectID":"/unix-io-models/:0:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#"},{"categories":["操作系统"],"content":"Blocking I/O Model 最常见的是 blocking I/O model。默认情况下，所有的 socket 都是阻塞的（blocking）。下图以 UDP datagram socket 为例，描述这种模型的工作方式： 图 1 上图中发生两次上下文切换，应用调用 recvfrom 时从运行在应用中（running in the application）切换至运行在内核中（running in the kernel）。成功返回时，从内核切换回应用。 ","date":"2021-12-11","objectID":"/unix-io-models/:1:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#blocking-io-model"},{"categories":["操作系统"],"content":"Nonblocking I/O Model 当我们将 socket 设置为 nonblocking 时，我们正在告诉内核 “如果不让进程休眠，我请求的操作就无法完成，那就别让进程休眠，而是立即返回一个错误”。 图 2 前三次我们调用 recvfrom，都没有数据可返回，因此内核立即返回一个 EWOULDBLOCK 错误。第四次尝试时，一个数据报（datagram）就绪了，它被拷贝至应用缓冲区。在拷贝期间，应用进程一直阻塞。 应用在一个循环中在一个 nonblocking descriptor 上调用 recvfrom，这就是轮询（polling）。这往往会浪费 CPU 时间，还好偶尔会遇到这个模型，通常在专注于单一功能的系统上。 ","date":"2021-12-11","objectID":"/unix-io-models/:2:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#nonblocking-io-model"},{"categories":["操作系统"],"content":"I/O Multiplexing Model 对 I/O Multiplexing 来说，我们调用 select 或 poll 并阻塞在这两个系统调用之一上，而非阻塞在实际的 I/O 系统调用上。 图 3 跟 blocking model 比较，这个模型好像没有任何优势，反而还有轻微的劣势，因为它有两次系统调用，而非一次。但它的优势在于，我们一次可以等待多个描述符就绪（ready）。 另一个紧密相关的 I/O 模型是将多线程跟 blocking I/O 一起使用。该模型非常像 multiplexing model，除了它不是阻塞在多个文件描述符上，而是使用多个线程（每个文件描述符一个）自由地调用像 recvfrom 这样的阻塞系统调用（blocking system call）。 ","date":"2021-12-11","objectID":"/unix-io-models/:3:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#io-multiplexing-model"},{"categories":["操作系统"],"content":"Signal-Driven Model 我们也可以告诉内核，当描述符就绪的时候，请它使用 SIGIO 信号通知我们。 图 4 为了启用 signal-driven I/O，我们先对 socket 做一些设置。然后使用 sigaction 系统调用安装一个信号处理器。安装完信号处理器后，进程就继续去做其他事情了，无需阻塞等待数据报（datagram）达到。当信号处理器收到信号时，要么它先调用 recvfrom 将数据报读到应用缓冲区再通知 main loop 数据报可处理了，要么它通知 main loop 数据报可读取了并让 main loop 来读取数据。 ","date":"2021-12-11","objectID":"/unix-io-models/:4:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#signal-driven-model"},{"categories":["操作系统"],"content":"Async I/O Model asynchronous I/O 由 POSIX 规范定义。async func 告诉内核，开始期望的操作并在整个操作完成（包括将数据报从内核拷贝至应用缓冲区）时通知我们。这个模型跟前一节描述的信号驱动的模型之间主要的不同之处在于，使用信号驱动，当一个 I/O 操作可以启动（can be initiated）时内核就通知我们；而使用 async I/O，当一个 I/O 操作完成时内核才通知我们。 图 4 我们调用 aio_read 函数（POSIX 异步 I/O 函数的名称以 aio_ 或 lio 开始），并将 descriptor、buffer pointer、buffer size、file offset (类似于 lseek)、当整个操作完成时如何通知我们 这 5 个参数传给内核。 ","date":"2021-12-11","objectID":"/unix-io-models/:5:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#async-io-model"},{"categories":["操作系统"],"content":"I/O 模型之间的比较 前 4 个模型之间的主要不同在第一阶段，因为它们的第二阶段是相同的：在将数据从内核拷贝至应用缓冲区期间进程阻塞在 recvfrom 系统调用上。然而，async I/O 跟前 4 个不同，一次异步函数调用处理这两个阶段，在此期间进程继续处理其他事情。 图 5 ","date":"2021-12-11","objectID":"/unix-io-models/:6:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#io-模型之间的比较"},{"categories":["操作系统"],"content":"Sync I/O vs Async I/O POSIX 定义了如下两个术语： 一个 sync I/O 操作会导致请求进程阻塞，直到 I/O 操作完成。 一个 async I/O 操作不会导致请求进程阻塞。 根据这个定义，前 4 个模型都是同步的，因为使用它们时 实际的 I/O 操作（recvfrom） 都会阻塞进程。只有 async I/O 模型满足 async I/O 的定义。 注意 sync 和 async I/O 并不是具体的 I/O model，只是根据 请求进程是否被阻塞直到 I/O 操作完成 这一点对 I/O model 的分类而已。因此它们不像 I/O model 那样描述 I/O 操作的具体工作方式。 ","date":"2021-12-11","objectID":"/unix-io-models/:7:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#sync-io-vs-async-io"},{"categories":["操作系统"],"content":"常见问题与错误理解 blocking/non-blocking I/O 与 sync/async I/O 之间有什么区别？ 我们先看问题本身，blocking/non-blocking I/O 确实是具体的 I/O model。但如果 sync/async I/O 指的是 I/O model，问题描述本身就有错误，因为没有一个具体的 I/O model 叫 sync I/O；如果指的是上一节中讲述的对 I/O model 的分类，也需要对问题描述做些调整，以便说清楚要对比的两个对象是什么。 有人认为，I/O 有阻塞/非阻塞、同步/异步这分，这两个维度是正交的，两两组合就得到四种 I/O model。 这个理解错在，这两个维度并非是正交的，因此不能两两组合以描述每种具体的 I/O model。根据上一节内容可知，sync I/O 这个分类包含了所有在 I/O 操作完成前会阻塞请求进程的 I/O model，因此这两个维度不是正交的。 ","date":"2021-12-11","objectID":"/unix-io-models/:8:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#常见问题与错误理解"},{"categories":["操作系统"],"content":"参考资料 《UNIX Network Programming Volume 1, Third Edition》6.2 I/O Models ","date":"2021-12-11","objectID":"/unix-io-models/:9:0","series":null,"tags":["IO"],"title":"Unix IO models","uri":"/unix-io-models/#参考资料"},{"categories":["编程笔记"],"content":"最近开始尝试使用 Gradle 构建项目，踩了一些坑，简略记录以备忘。 Gradle 项目可以使用 Gradle Wrapper (简称 Wrapper)，也可以不使用。Wrapper 的主要目的是将项目构建依赖的 Gradle 版本配置化，作为构建脚本的一部分。Wrapper 只是一个脚本，它调用指定版本的 Gradle；如果指定版本的 Gradle 不存在，就下载并自动安装，避免开发者手动安装。官方推荐使用 Wrapper 执行任何 Gradle build。可是墙内下载 Gradle 非常慢，一开始还不知道为啥必须下载，如何加速，这让人很懊恼。如何使用 Wrapper，请看 The Gradle Wrapper。 解决办法有两个，但都需要先手工把对应版本下载到本地。 办法一 部署 HTTP Server (如 Nginx)，把下载的文件放入站点目录。 修改 {Gradle Project}/gradle/wrapper/gradle-wrapper.properties 文件，将 distributionUrl 设置为本地或内网的可用下载地址。 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists #distributionUrl=https\\://services.gradle.org/distributions/gradle-6.6.1-bin.zip distributionUrl=http\\://localhost:8080/gradle-6.6.1-bin.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists 注意，对于 properties 文件，name/value 的分隔符是 ‘=’ 或 ‘:'，所以如果 value 中包含这两个字符，记得用 \\ 进行转义。 办法二 把下载文件放到本地某个目录，例如：/Users/{user}/Cellar/gradle-6.6.1-bin.zip 修改 {Gradle Project}/gradle/wrapper/gradle-wrapper.properties 文件，将 distributionUrl 设置为本地文件路径： distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists #distributionUrl=https\\://services.gradle.org/distributions/gradle-6.6.1-bin.zip distributionUrl=file\\:///Users/xxx/Cellar/gradle-6.6.1-bin.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists 最后，在项目根目录运行命令 ./gradlew build 检查效果如何。 ","date":"2020-12-16","objectID":"/gradle-%E9%87%87%E5%9D%91%E8%AE%B0/:0:0","series":["Gradle使用"],"tags":["java"],"title":"Gradle 采坑记","uri":"/gradle-%E9%87%87%E5%9D%91%E8%AE%B0/#"},{"categories":null,"content":"还不知道该说些什么 ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"","uri":"/about/#"}]